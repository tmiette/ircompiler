package ${toolsProcessor.packageName};

#foreach($import in $variableImports)
import ${import.rawName};
#end
import ${ruleEnum.rawName};
import ${terminalEnum.rawName};
import ${nonTerminalEnum.rawName};
import ${productionEnum.rawName};
import ${terminalEvaluator.rawName};
import ${grammarEvaluator.rawName};

import fr.umlv.tatoo.runtime.buffer.LexerBuffer;
import fr.umlv.tatoo.runtime.lexer.LexerListener;
import fr.umlv.tatoo.runtime.parser.SimpleParser;
import fr.umlv.tatoo.runtime.parser.SmartStepReturn;
import fr.umlv.tatoo.runtime.tools.DataViewer;
import fr.umlv.tatoo.runtime.tools.GenericStack;
import fr.umlv.tatoo.runtime.tools.AbstractToolsProcessor;

/**  This class is called by the parser when
 *   <ol>
 *    <li>a terminal is shifted
 *    <li>a non terminal is reduced
 *    <li>a non terminal is accepted
 *   </ol>
 *   In that case, depending on the information of the .xtls, terminal and non-terminal
 *   values are pushed or pop from a semantic stack.
 *   
 *   Furthermore, in case of error recovery, values of the stack can be pop out
 *   depending if the last recognized element is a terminal or a non-terminal.
 * 
 *  This class is generated - please do not edit it 
 */
public class ${toolsProcessor.simpleName}<B extends LexerBuffer,D>
  extends AbstractToolsProcessor<B,${ruleEnum.simpleName},${terminalEnum.simpleName},${nonTerminalEnum.simpleName},${productionEnum.simpleName}> {
 
  B buffer;
    
#set($ruleNeeded=false)#foreach($t in $terminals) #if($terminalRules.get($t).size() > 1)#set($ruleNeeded = true)#end#end
#if($ruleNeeded)
  ${ruleEnum.simpleName} rule;
#end

  private final GrammarEvaluator grammarEvaluator;
  private final TerminalEvaluator<? super D> terminalEvaluator;
  private final DataViewer<? super B,? extends D> dataViewer;
  private final GenericStack stack;

  /** Creates a tools processor.
      This constructor allows to share the same stack between more
      than one parser processor.
      @param terminalEvaluator the terminal evaluator.
      @param grammarEvaluator the grammar evaluator.
      @param stack the stack used by the processor
   */
  private ${toolsProcessor.simpleName}(${terminalEvaluator.simpleName}<? super D> terminalEvaluator, ${grammarEvaluator.simpleName} grammarEvaluator, DataViewer<? super B,? extends D> dataViewer, GenericStack stack) {
    this.terminalEvaluator=terminalEvaluator;
    this.grammarEvaluator=grammarEvaluator;
    this.dataViewer=dataViewer;
    this.stack=stack;
  }
  
  public static <B extends LexerBuffer,D> AbstractToolsProcessor<B,${ruleEnum.simpleName},${terminalEnum.simpleName},${nonTerminalEnum.simpleName},${productionEnum.simpleName}>
    createToolsProcessor(${terminalEvaluator.simpleName}<? super D> terminalEvaluator, ${grammarEvaluator.simpleName} grammarEvaluator, DataViewer<? super B,? extends D> dataViewer, GenericStack stack) {
    
    return new ${toolsProcessor.simpleName}<B,D>(terminalEvaluator,grammarEvaluator,dataViewer,stack);
  }
  
  /** Creates a lexer listener that forwards recognized rule to the parser.
   * @param parser a parser
   * @return a lexer listener.
   */
  @Override
  public LexerListener<RuleEnum,B> createLexerListener(SimpleParser<? super TerminalEnum> parser) {
    return new LexerAdapter(parser);
  }
  
  protected class LexerAdapter implements LexerListener<RuleEnum,B> {
    private final SimpleParser<? super TerminalEnum> parser;
    
    protected LexerAdapter(SimpleParser<? super TerminalEnum> parser) {
      this.parser=parser;
    }
    
    
    /**
     * {@inheritDoc}
     */
    public final void ruleVerified(RuleEnum rule, int lastTokenLength,B buffer)  {   
    ${toolsProcessor.simpleName}.this.buffer=buffer; 
    try {
      switch(rule) {
#foreach ($rule in $rules)
        case ${rule.id}:
 #set($info = $ruleInfoMap.get($rule))
 #if ($info.isSpawnable())
  #if ($info.terminal)
   #if($terminalRules.get($info.terminal).size() > 1)
          ${toolsProcessor.simpleName}.this.rule = rule;
   #end 
          if (parser.smartStep(${terminalEnum.simpleName}.${info.terminal.id})==SmartStepReturn.RELEX) {
            buffer.restart();
            return;
          }
  #else
          // no terminal defined for rule  ${rule.id}
  #end
 #else
  #if($info.isDiscardable())
          buffer.discard();
  #end
 #end
          return;
#end
        }
        throw new AssertionError("unknown rule "+rule);
      }
      finally {
        ${toolsProcessor.simpleName}.this.buffer = null;
      }
    }
  }

  public void shift(${terminalEnum.simpleName} terminal) {
     D data;
     switch(terminal) {
#foreach($t in $terminals)
      case ${t.id}: {
 #set($type=false)#set($type = $terminalTypeMap.get($t))
 #if ($type)
        data=dataViewer.view(${toolsProcessor.simpleName}.this.buffer);
 #end
 #set($ruleSet=false)#set($ruleSet = $terminalRules.get($t))
 #if ($ruleSet)
  #if ($ruleSet.size() == 1)
   #set($rule = $ruleSet.iterator().next())
   #if ($type)
     #if (!$type.isVoid()) $type ${t.id}=#end terminalEvaluator.${rule.id}(data);
   #end
   #if ($ruleInfoMap.get($rule).isDiscardable())
           ${toolsProcessor.simpleName}.this.buffer.discard();
   #end
  #else
   #if ($type && !$type.isVoid()) 
        $type ${t.id};
   #end
        switch(${toolsProcessor.simpleName}.this.rule) {
   #foreach($rule in $ruleSet)
          case ${rule}:
    #if ($type)
      #if (!$type.isVoid()) ${t.id}=#end terminalEvaluator.${rule.id}(data);
    #end
    #if ($ruleInfoMap.get($rule).isDiscardable())
            ${toolsProcessor.simpleName}.this.buffer.discard();
    #end
            break;
   #end
          default:
             throw new AssertionError("Unknown rule " +${toolsProcessor.simpleName}.this.rule);
        }
  #end
 #end       
 #if ($type && !$type.isVoid())
        stack.push_${type.getVMTypeName()}(${t.id});
 #end
        return;
      }
#end
    }
    throw new AssertionError("unknown terminal "+terminal);
  }

#macro(grammarEvaluator $prod)grammarEvaluator.${prod.id}(#foreach ($p in $params.get($prod.right))#if($velocityCount!=1), #end${p.name}#end)#end
  @SuppressWarnings("unchecked")
  public void reduce(${productionEnum.simpleName} production) {
    switch(production) {
#foreach($prod in $productions)
      case ${prod.id}: {
#set($t=false)#set($t=$variableTypeMap.get($prod.left))
#set($starType="NO_STAR")#set($starType=${ebnfSupport.get($prod).toString()})
#set($ast=${astSet.contains($prod)})
// ast $ast
// starType $starType
#if($starType=="NO_STAR")
#foreach ($param in $params.getReverse($prod.right))
#* FIXME Remi check void/null here ? *#
          ${param.type.simpleName} ${param.name}=#if(!$param.type.primitive)(${param.type.simpleName})#end stack.pop_${param.type.getVMTypeName()}();
#end
#if ($t && !$t.isVoid())
          stack.push_${t.getVMTypeName()}(#grammarEvaluator($prod));
#else
  #if ($params.notAllNull($prod.right) || $t)
          #grammarEvaluator($prod);
  #end
#end
#end
#if($starType=="OPTIONAL_EMPTY")
          // optional empty
#if($t && !$t.isVoid())
          stack.push_${t.getVMTypeName()}(${t.defaultValue});
#end
#end
#if($starType=="OPTIONAL_SINGLETON")
          // optional singleton    
#end
#if($starType=="STAR_EMPTY")
          // star empty $t
#if($t && !$t.isVoid())
#if($ast)
          stack.push_Object(new ${t.simpleName}());
#else
          stack.push_Object(new java.util.ArrayList<Object>());
#end
#end
#end
#if($starType=="STAR_SINGLETON")
          // star singleton
#if($t && !$t.isVoid())
#set($elementType=${params.get(${prod.right}).get(0).type})
#if($ast)
          ${t.simpleName} node=new ${t.simpleName}();
          node.nodeList().add((${elementType.simpleName})stack.pop_Object());
          stack.push_Object(node);
#else
          java.util.ArrayList<${elementType.boxIfPrimitive().simpleName}> list=new java.util.ArrayList<${elementType.boxIfPrimitive().simpleName}>();
#* FIXME Remi check void/null here ? *#
          list.add(#if(!$elementType.primitive)(${elementType.simpleName})#end stack.pop_${elementType.getVMTypeName()}());
          stack.push_${t.getVMTypeName()}(list);
#end
#end
#end
#if($starType=="STAR_RECURSIVE_LEFT")
          // star recursive left
#if($t && !$t.isVoid())
#set($list=${params.get(${prod.right}).get(0)})
#set($element=${params.get(${prod.right}).get(1)})
#if($ast)
          ${element.type.simpleName} ${element.name}=(${element.type.simpleName})stack.pop_Object();
          ${list.type.simpleName} ${list.name}=(${list.type.simpleName})stack.pop_Object();
          ${list.name}.nodeList().add(${element.name});
          stack.push_Object(${list.name});
#else
          ${element.type.simpleName} ${element.name}=#if (!$element.type.primitive)(${element.type.simpleName})#end stack.pop_${element.type.getVMTypeName()}();
          ${list.type.simpleName} ${list.name}=#if(!$list.type.primitive)(${list.type.simpleName})#end stack.pop_${list.type.getVMTypeName()}();
          ${list.name}.add(${element.name});
          stack.push_${t.getVMTypeName()}(${list.name});
#end
#end
#end
#if($starType=="STAR_RECURSIVE_RIGHT")
          // recursive right
#if($t && !$t.isVoid())
#set($list=${params.get(${prod.right}).get(1)})
#set($element=${params.get(${prod.right}).get(0)})
#if($ast)
          ${list.type.simpleName} ${list.name}=(${list.type.simpleName})stack.pop_Object();
          ${element.type.simpleName} ${element.name}=(${element.type.simpleName})stack.pop_Object();
          ${list.name}.nodeList().add(${element.name});
          stack.push_Object(${list.name});
#else
          ${list.type.simpleName} ${list.name}=#if (!$list.type.primitive)(${list.type.simpleName})#end stack.pop_${list.type.getVMTypeName()}();
          ${element.type.simpleName} ${element.name}=#if (!$element.type.primitive)(${element.type.simpleName})#end stack.pop_${element.type.getVMTypeName()}();
          ${list.name}.add(${element.name});
          stack.push_${t.getVMTypeName()}(${list.name});
#end
#end
#end
#if($starType=="STAR_PASS_THROUGH")
          // pass through
#end
          return;
      }
#end
    }
    throw new AssertionError("unknown production "+production);
  }

  @SuppressWarnings("unchecked")
  public void accept(${nonTerminalEnum.simpleName} nonterminal) {
    switch(nonterminal) {
#foreach ($nt in $starts)
      case ${nt.id}:
#set($type=false)#set($type=$variableTypeMap.get($nt))
#set($acceptName=$upperCaser.toUpperCase($nt))
#if ($type)
        grammarEvaluator.accept${acceptName}(#if(!$type.primitive)(${type.simpleName})#end #if(!$type.isVoid())stack.pop_${type.getVMTypeName()}()#end);
#*else
        grammarEvaluator.accept${acceptName}();*#
#end
        return;
#end
      default:
    }
    throw new AssertionError("unknown start nonterminal "+nonterminal);
  }

  public void popTerminalOnError(${terminalEnum.simpleName} terminal) {
    switch(terminal) {
#foreach ($t in $terminals)
      case ${t.id}:
#set($type=false)#set($type=$terminalTypeMap.get($t))
#if ($type && !$type.isVoid())
        stack.pop_${type.getVMTypeName()}();
#end
        return;
#end
    }
    throw new AssertionError("unknown terminal "+terminal);
  }

  public void popNonTerminalOnError(${nonTerminalEnum.simpleName} nonterminal) {
    switch(nonterminal) {
#foreach ($nt in $nonTerminals)
      case ${nt.id}:
#set($type=false)#set($type=$variableTypeMap.get($nt))
#if ($type && !$type.isVoid())
        stack.pop_${type.getVMTypeName()}();
#end
        return;
#end
    }
    throw new AssertionError("unknown nonterminal "+nonterminal);
  }
}
