/*
 * Created on Jun 17, 2003
 *
 */
package fr.umlv.tatoo.runtime.lexer.rules;

import java.util.ArrayList;

import fr.umlv.tatoo.runtime.util.IntArrayList;

/** This class contains the live data used to process
 *  one rule of the lexer.
 *  
 *  A rule data is break down in one regular expression
 *  and one optional regular expresison represented by the
 *  class {@link RuleData}.
 *  
 *  The state of the automaton of a regular expression
 *  is represented by the class {@link DFA}.
 * 
 * @author Julien Cervelle
 * @param <R> type of rules.
 *
 * @see RuleData
 * @see DFA
 */
public class Action<R> {
  /** Creates an action.
   * 
   */
  public Action() {
    subProcesses = new ArrayList<DFA>();
    positions = new IntArrayList();
    main = new DFA();
  }
  
  /** Reuse the action with a new rule and its data.
   * 
   * @param rule the lexer rule
   * @param ruleData the data generated by Tatoo lexer containing 
   *    the two regular expressions associated with the rule
   */
  public void reset(R rule,RuleData ruleData) {
    //System.out.println(hashCode()+" reset with rule "+rule);
    this.rule=rule;
    this.ruleData=ruleData;
    main.reset(ruleData.getMainRegex());
    if(hasFollowing)
      resetProcesses();
    charNo = 0;
    lastMatch = -1;
    mainProcessFinished = false;
    //System.out.println(mainProcessFinished);
    RegexTable following = ruleData.getFollowRegex();
    if (following == null || containsEspilon(following)) {
      hasFollowing = false;
    } else {
      hasFollowing = true;
    }
  }
  
  /** Steps by one letter on the internal automaton and
   *  returns false if the letter is rejected or
   *  accepted by the automaton.
   * 
   * @param a the letter
   * @return true is a futher step is needed in order
   *  to parse a token.
   */
  @SuppressWarnings("fallthrough")
  public boolean step(int a) {
    //System.out.println(hashCode()+" "+rule+"#### "+a);
    //System.out.println(mainProcessFinished);
    charNo++;
    if (!hasFollowing) {
      DFA.ReturnCode result = main.step(a);
      switch (result) {
      case REJECT :
        return false;
      case FINAL_ACCEPT :
        lastMatch = charNo;
        return false;
      case ACCEPT :
        lastMatch = charNo;
        return true;
      case CONTINUE :
        return true;
      default :
        throw new InternalError("unknown process result");
      }
    } else {
      //System.out.println(rule+"###");
      for (int i=0;i<positions.size();i++) {
        DFA process = subProcesses.get(i);
        //System.out.println(rule + " DFA "+i+" stepping for " + a);
        DFA.ReturnCode result = process.step(a);
        //System.out.println(result);
        switch (result) {
        case REJECT :
          removeProcess(i);
          break;
        case FINAL_ACCEPT :
        case ACCEPT :
          lastMatch = Math.max(lastMatch, positions.get(i));
          removeProcess(i);
        case CONTINUE :
          break;
        default :
          throw new InternalError("unknown process result");
        }
      }
      if (mainProcessFinished) {
        //System.out.println("fini");
        return !positions.isEmpty();
      } else {
        //System.out.println(rule + " DFA stepping for " + a);
        DFA.ReturnCode result = main.step(a);
        //System.out.println(result);
        switch (result) {
        case REJECT :
          //System.out.println("cici");
          mainProcessFinished = true;
          return !positions.isEmpty();
        case FINAL_ACCEPT :
          //System.out.println("cici2");
          mainProcessFinished = true;
        case ACCEPT :
          addProcess();
          return true;
        case CONTINUE :
          return true;
        default :
          throw new InternalError("unknown process result");
        }
      }
    }
  }
  
  private void removeProcess(int i) {
    //System.out.println("rem "+i);
    //System.out.println(positions.size());
    int max = positions.size()-1;
    if (i!=max) {
      DFA tmp = subProcesses.get(i);
      subProcesses.set(i, subProcesses.get(max));
      subProcesses.set(max,tmp);
      positions.set(i,positions.get(max));
    }
    positions.removeLast(1);
    //System.out.println(positions.size());
  }
  
  private void addProcess() {
    int pos = positions.size();
    positions.add(charNo);
    if (pos < subProcesses.size()) {
      subProcesses.get(pos).reset();
    } else {
      subProcesses.add(new DFA(ruleData.getFollowRegex()));
    }
  }
  
  private void resetProcesses() {
    positions.clear();
  }
  
  /** Returns the last buffer position that has matched the rule.
   * @return the last buffer position that has matched the rule.
   */
  public int lastMatch() {
    return lastMatch;
  }

  /** Returns the rule of the current action.
   * @return the rule of the current action.
   */
  public R getRule() {
    return rule;
  }
    
  private R rule;
  private RuleData ruleData;
  private boolean hasFollowing;
  private int charNo;
  private int lastMatch;
  private boolean mainProcessFinished;
  private final DFA main;
  private final ArrayList<DFA> subProcesses;
  private final IntArrayList positions;
  
  private static boolean containsEspilon(RegexTable table) {
    return table.accept(table.getStart());
  }
}
